syntax = "proto3";

package agynio.api.runner.v1;

import "google/protobuf/timestamp.proto";

// RunnerService mirrors the current docker-runner HTTP+WS+SSE surface,
// but replaces unary exec/run with a single streaming-only Exec RPC.
service RunnerService {
  // Health/readiness
  rpc Ready(ReadyRequest) returns (ReadyResponse);

  // Images
  rpc EnsureImage(EnsureImageRequest) returns (EnsureImageResponse);

  // Targets (containers today)
  rpc StartTarget(StartTargetRequest) returns (StartTargetResponse);
  rpc StopTarget(StopTargetRequest) returns (StopTargetResponse);
  rpc RemoveTarget(RemoveTargetRequest) returns (RemoveTargetResponse);

  // Minimal inspect surface with EXACT fields required by platform today.
  rpc InspectTarget(InspectTargetRequest) returns (InspectTargetResponse);

  rpc GetTargetLabels(GetTargetLabelsRequest) returns (GetTargetLabelsResponse);
  rpc GetTargetNetworks(GetTargetNetworksRequest) returns (GetTargetNetworksResponse);

  rpc FindTargetsByLabels(FindTargetsByLabelsRequest) returns (FindTargetsByLabelsResponse);
  rpc ListTargetsByVolume(ListTargetsByVolumeRequest) returns (ListTargetsByVolumeResponse);

  rpc RemoveVolume(RemoveVolumeRequest) returns (RemoveVolumeResponse);

  rpc TouchTarget(TouchTargetRequest) returns (TouchTargetResponse);

  rpc PutArchive(PutArchiveRequest) returns (PutArchiveResponse);

  // Streaming logs/events (SSE equivalents)
  rpc StreamTargetLogs(StreamTargetLogsRequest) returns (stream StreamTargetLogsResponse);
  rpc StreamEvents(StreamEventsRequest) returns (stream StreamEventsResponse);

  // Exec (streaming-only; replaces /v1/exec/run and /v1/exec/interactive/ws)
  rpc Exec(stream ExecRequest) returns (stream ExecResponse);

  // Cancellation for a previously started execution_id.
  rpc CancelExecution(CancelExecutionRequest) returns (CancelExecutionResponse);
}

// -------------------- Common --------------------

message ReadyRequest {}

message ReadyResponse {
  string status = 1; // e.g. "ok"
}

message RunnerError {
  string code = 1;
  string message = 2;
  map<string, string> details = 3;
  bool retryable = 4;
}

// -------------------- Images --------------------

enum Platform {
  PLATFORM_UNSPECIFIED = 0;
  PLATFORM_LINUX_AMD64 = 1;
  PLATFORM_LINUX_ARM64 = 2;
}

message EnsureImageRequest {
  string image = 1;
  Platform platform = 2; // PLATFORM_UNSPECIFIED means "backend default"
}

message EnsureImageResponse {}

// -------------------- Target lifecycle --------------------

message EnvVar {
  string name = 1;
  string value = 2;
}

message StartTargetRequest {
  string image = 1;
  string name = 2;
  repeated string cmd = 3;
  string entrypoint = 4;

  repeated EnvVar env = 5;

  string working_dir = 6;
  bool auto_remove = 7;

  // Bind mounts in Docker form "hostPath:containerPath[:ro|rw]".
  repeated string binds = 8;

  // Network mode / network name.
  string network_mode = 9;

  bool tty = 10;

  map<string, string> labels = 11;

  Platform platform = 12;

  bool privileged = 13;

  // Anonymous volumes (container paths).
  repeated string anonymous_volumes = 14;

  // TTL hint for garbage collection.
  uint32 ttl_seconds = 15;
}

message StartTargetResponse {
  string target_id = 1;
  string name = 2;
  string status = 3;
}

message StopTargetRequest {
  string target_id = 1;
  uint32 timeout_sec = 2;
}

message StopTargetResponse {}

message RemoveTargetRequest {
  string target_id = 1;
  bool force = 2;
  bool remove_volumes = 3;
}

message RemoveTargetResponse {}

message InspectTargetRequest {
  string target_id = 1;
}

// EXACT fields used today in platform:
// id, name, image, config_image, config_labels, mounts, state_status, state_running
message InspectTargetResponse {
  string id = 1;
  string name = 2;

  string image = 3;
  string config_image = 4;
  map<string, string> config_labels = 5;

  repeated TargetMount mounts = 6;

  string state_status = 7;
  bool state_running = 8;
}

message TargetMount {
  string type = 1;
  string source = 2;
  string destination = 3;
  bool read_only = 4;
}

message GetTargetLabelsRequest {
  string target_id = 1;
}

message GetTargetLabelsResponse {
  map<string, string> labels = 1;
}

message GetTargetNetworksRequest {
  string target_id = 1;
}

message GetTargetNetworksResponse {
  repeated string networks = 1;
}

message FindTargetsByLabelsRequest {
  map<string, string> labels = 1;
  bool all = 2;
}

message FindTargetsByLabelsResponse {
  repeated string target_ids = 1;
}

message ListTargetsByVolumeRequest {
  string volume_name = 1;
}

message ListTargetsByVolumeResponse {
  repeated string target_ids = 1;
}

message RemoveVolumeRequest {
  string volume_name = 1;
  bool force = 2;
}

message RemoveVolumeResponse {}

message TouchTargetRequest {
  string target_id = 1;
}

message TouchTargetResponse {}

message PutArchiveRequest {
  string target_id = 1;
  string path = 2;
  bytes tar_payload = 3;
}

message PutArchiveResponse {}

// -------------------- Logs streaming --------------------

message StreamTargetLogsRequest {
  string target_id = 1;

  bool follow = 2;
  int64 since = 3; // epoch seconds; 0 = unset
  uint32 tail = 4; // 0 = backend default
  bool stdout = 5;
  bool stderr = 6;
  bool timestamps = 7;
}

message StreamTargetLogsResponse {
  oneof event {
    LogChunk chunk = 1;
    LogEnd end = 2;
    RunnerError error = 3;
  }
}

message LogChunk {
  bytes data = 1;
  google.protobuf.Timestamp ts = 2;
}

message LogEnd {}

// -------------------- Runtime events streaming --------------------

message StreamEventsRequest {
  int64 since = 1; // epoch seconds; 0 = unset
  repeated EventFilter filters = 2;
}

message EventFilter {
  string key = 1;
  repeated string values = 2;
}

message StreamEventsResponse {
  oneof event {
    RunnerEventData data = 1;
    RunnerError error = 2;
  }
}

message RunnerEventData {
  // Opaque JSON representation (preserves parity with docker events passthrough).
  string json = 1;
  google.protobuf.Timestamp ts = 2;
}

// -------------------- Exec (streaming-only) --------------------

message ExecRequest {
  oneof msg {
    ExecStartRequest start = 1;
    ExecStdin stdin = 2;
    ExecResize resize = 3;
  }
}

message ExecStartRequest {
  string request_id = 1;

  string target_id = 2;

  // Exactly one must be set.
  repeated string command_argv = 3;
  string command_shell = 4;

  ExecOptions options = 5;
}

message ExecOptions {
  string workdir = 1;
  repeated EnvVar env = 2;

  uint64 timeout_ms = 3;
  uint64 idle_timeout_ms = 4;

  bool tty = 5;
  bool separate_stderr = 6;

  bool kill_on_timeout = 7;
  bool log_to_pid1 = 8;

  uint64 exit_tail_bytes = 9;
}

message ExecStdin {
  bytes data = 1;
  bool eof = 2;
}

message ExecResize {
  uint32 cols = 1;
  uint32 rows = 2;
}

message ExecResponse {
  oneof event {
    ExecStarted started = 1;
    ExecOutput stdout = 2;
    ExecOutput stderr = 3;
    ExecExit exit = 4;
    ExecError error = 5;
  }
}

message ExecStarted {
  string execution_id = 1;
  google.protobuf.Timestamp started_at = 2;
}

message ExecOutput {
  uint64 seq = 1;
  bytes data = 2;
  google.protobuf.Timestamp ts = 3;
}

message ExecExit {
  string execution_id = 1;
  int32 exit_code = 2;

  bool killed = 3;
  ExecExitReason reason = 4;

  bytes stdout_tail = 5;
  bytes stderr_tail = 6;

  google.protobuf.Timestamp finished_at = 7;
}

enum ExecExitReason {
  EXEC_EXIT_REASON_UNSPECIFIED = 0;
  EXEC_EXIT_REASON_COMPLETED = 1;
  EXEC_EXIT_REASON_TIMEOUT = 2;
  EXEC_EXIT_REASON_IDLE_TIMEOUT = 3;
  EXEC_EXIT_REASON_CANCELLED = 4;
  EXEC_EXIT_REASON_RUNNER_ERROR = 5;
}

message ExecError {
  string code = 1;
  string message = 2;
  bool retryable = 3;
}

message CancelExecutionRequest {
  string execution_id = 1;
  bool force = 2;
}

message CancelExecutionResponse {
  bool cancelled = 1;
}
