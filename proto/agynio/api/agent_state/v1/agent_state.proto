syntax = "proto3";

package agynio.api.agent_state.v1;

import "google/protobuf/timestamp.proto";

option go_package = "github.com/agynio/api/gen/agynio/api/agent_state/v1;agentstatev1";

// Agent Persistent State Service (APSS)
// - conversationId-only API (threadId/nodeId mapping handled outside)
// - ordered messages via monotonic seq per conversation
// - conversation-level version for optimistic concurrency (CAS/ETag)
// - message bodies are well-typed; text-only now, extensible via oneof
// - no external type references

service AgentStateService {
  // Append messages (batch). Server assigns seq; bumps conversation version.
  rpc AppendConversationMessages(AppendConversationMessagesRequest) returns (AppendConversationMessagesResponse);

  // List messages with filtering & pagination.
  rpc ListConversationMessages(ListConversationMessagesRequest) returns (ListConversationMessagesResponse);

  // Delete messages by id.
  rpc DeleteConversationMessages(DeleteConversationMessagesRequest) returns (DeleteConversationMessagesResponse);

  // Insert messages relative to an anchor seq.
  rpc InsertConversationMessages(InsertConversationMessagesRequest) returns (InsertConversationMessagesResponse);

  // Get conversation metadata (version, last_seq, message_count).
  rpc GetConversation(GetConversationRequest) returns (GetConversationResponse);

  // List message IDs in a conversation (filtered, paginated).
  rpc ListConversationMessageIds(ListConversationMessageIdsRequest) returns (ListConversationMessageIdsResponse);

  // List messages in a snapshot (exact stored order, paginated).
  rpc ListSnapshotMessages(ListSnapshotMessagesRequest) returns (ListSnapshotMessagesResponse);

  // List message IDs in a snapshot (exact stored order, paginated).
  rpc ListSnapshotMessageIds(ListSnapshotMessageIdsRequest) returns (ListSnapshotMessageIdsResponse);

  // Create a materialized context snapshot for a specific LLM call.
  // The client supplies the exact message IDs; APSS stores
  // a materialized copy of each message body in the provided order.
  // This guarantees reproducibility even after trims/edits.
  rpc CreateSnapshot(CreateSnapshotRequest) returns (CreateSnapshotResponse);

}

enum Role {
  ROLE_UNSPECIFIED = 0;
  ROLE_USER = 1;
  ROLE_ASSISTANT = 2;
  ROLE_TOOL = 3;
}

// Optional attributes for memory-like messages.
message MemoryAttrs {
  enum Place {
    PLACE_UNSPECIFIED = 0;
    PLACE_AFTER_SYSTEM = 1;
    PLACE_LAST_MESSAGE = 2;
  }
  Place place = 1;
}

// Text payload for now. Future extensions can add more oneof variants.
message TextBody { string text = 1; }

message MessageBody {
  oneof body {
    TextBody text = 1;
    // Reserved for future extensions:
    // ImageBody image = 2;
    // AudioBody audio = 3;
  }
}

// Core message entity stored by APSS.
message Message {
  string id = 1;                    // server-assigned UUID
  string conversation_id = 2;       // routing key
  int64 seq = 3;                    // monotonic per conversation
  Role role = 4;                    // user | assistant | tool
  string kind = 5;                  // free-form tag (e.g., system, summary, memory, restriction, tool_output)
  MessageBody body = 6;             // payload
  MemoryAttrs memory = 7;           // optional placement attributes (for memory kinds)
  google.protobuf.Timestamp created_at = 8;
  bool archived = 9;                // soft delete / superseded flag
  google.protobuf.Timestamp archived_at = 10;
}

message ConversationMetadata {
  string conversation_id = 1;
  int64 version = 2;                // CAS token (monotonic)
  int64 last_seq = 3;               // highest seq among active messages
  int64 message_count = 4;          // count of active messages
  google.protobuf.Timestamp updated_at = 5;
}

// Append
message AppendMessageInput {
  Role role = 1;
  string kind = 2;
  MessageBody body = 3;
  MemoryAttrs memory = 4;           // optional, meaningful for memory kinds
}

message AppendConversationMessagesRequest {
  string conversation_id = 1;
  int64 expect_version = 2;         // optimistic concurrency; 0 to bypass on create
  string idempotency_key = 3;       // dedupe retries
  repeated AppendMessageInput messages = 4;
}

message AppendConversationMessagesResponse {
  ConversationMetadata metadata = 1;
  repeated Message appended = 2;
}

// List
message ListConversationMessagesRequest {
  string conversation_id = 1;
  repeated Role roles = 2;          // filter roles (optional)
  repeated string kinds = 3;        // filter kinds (optional)
  int64 seq_gte = 4;                // inclusive lower bound (optional)
  int64 seq_lte = 5;                // inclusive upper bound (optional)
  bool include_archived = 6;        // default false
  int32 page_size = 7;              // server may cap
  string page_token = 8;            // opaque cursor
  bool descending = 9;              // default ascending
}

message ListConversationMessagesResponse {
  ConversationMetadata metadata = 1;
  repeated Message messages = 2;
  string next_page_token = 3;
}

// Delete
message DeleteConversationMessagesRequest {
  string conversation_id = 1;
  int64 expect_version = 2;
  string idempotency_key = 3;
  repeated string message_ids = 4;
}

message DeleteConversationMessagesResponse {
  ConversationMetadata metadata = 1;
  repeated string deleted_message_ids = 2;
}

// Insert
message InsertConversationMessagesRequest {
  enum Placement {
    PLACEMENT_UNSPECIFIED = 0;
    PLACEMENT_BEFORE = 1;
    PLACEMENT_AFTER = 2;
  }
  string conversation_id = 1;
  int64 expect_version = 2;
  string idempotency_key = 3;
  int64 anchor_seq = 4;
  Placement placement = 5;
  repeated AppendMessageInput messages = 6;
}

message InsertConversationMessagesResponse {
  ConversationMetadata metadata = 1;
  repeated Message inserted = 2;
}

// Metadata
message GetConversationRequest { string conversation_id = 1; }
message GetConversationResponse { ConversationMetadata metadata = 1; }

// Create a materialized context snapshot for a specific LLM call.
// The client supplies the exact message IDs; APSS stores
// a materialized copy of each message body in the provided order.
// This guarantees reproducibility even after trims/edits.

// --------------------------
// Context Snapshots
// --------------------------

// A materialized snapshot of the exact context sent to an LLM call.
message ContextSnapshot {
  string snapshot_id = 1;                 // server-assigned UUID
  string conversation_id = 2;             // conversation this snapshot belongs to
  google.protobuf.Timestamp created_at = 4;
}

// Each snapshot item is a materialized message copy with integrity hash.
message SnapshotItem {
  string message_id = 1;                  // original message id
  int64 seq = 2;                          // original message seq
  Role role = 3;                          // original role
  string kind = 4;                        // original kind
  MessageBody body = 5;                   // materialized body copy
  string body_sha256 = 6;                 // integrity hash of the serialized body
}

message CreateSnapshotRequest {
  string conversation_id = 1;
  repeated string message_ids = 2;        // exact order to persist in the snapshot
}

message CreateSnapshotResponse {
  ContextSnapshot snapshot = 1;
}

// Snapshot listing RPCs
message ListSnapshotMessagesRequest {
  string snapshot_id = 1;
  int32 page_size = 2;
  string page_token = 3;
}

message ListSnapshotMessagesResponse {
  repeated Message messages = 1;
  string next_page_token = 2;
}

message ListSnapshotMessageIdsRequest {
  string snapshot_id = 1;
  int32 page_size = 2;
  string page_token = 3;
}

message ListSnapshotMessageIdsResponse {
  repeated string message_ids = 1;
  string next_page_token = 2;
}

message ListConversationMessageIdsRequest {
  string conversation_id = 1;
  int64 seq_gte = 2;
  int64 seq_lte = 3;
  bool include_archived = 4;
  int32 page_size = 5;
  string page_token = 6;
  bool descending = 7;
}

message ListConversationMessageIdsResponse {
  repeated string message_ids = 1;
  string next_page_token = 2;
}
